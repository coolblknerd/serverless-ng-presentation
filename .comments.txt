Below is a list of key commands for using Github presentations

~~~~~~~

--- ==> Denotes the start of a horizontal slide
+++ ==> Denotes the start of a vertical slide

```<language>/n<code>``` ==> Syntax highlighting

*<text>* || _<text>_ ==> Will make text italic
**<text>** || __<text>__ ==> Will make text bold

#<text> ==> h1 tag
##<text> ==> h2 tag
######<text> ==> h6 tag

![<image_name>](<path/to/img>) ==> Creates images

http://<domain_name>.com ==> Creates links

> <text> ==> Creates blockquotes

- [x] || [ ] ==> Creates checkboxes

Note: <text> ==> Creates speaker notes

~~~~~~

"The essence of the serverless trend is the absence of the server concept during software development."

Serverless frees the software developer from deployment concerns and allows them to focus on factoring the application following logical encapsulation lines.

With IaaS we are used to paying for servers' uptime regardless of their utilization level. This typically leads to a lot of waste given that a degree of overprovisioning is often the only sensible answer to capacity planning.

The lightweight nature of the programming abstraction in serverless combined with the economy of scale of the generic runtime enable a much quicker provisioning of the required computing resources (CPU, memory) within the infrastructure that runs the code. Functions are created, executed, and resources are reclaimed. The end user is paying only for the actual time and resources consumed.

Ephermeral compute containers used to execute functions.

***With FaaS you need to write the function ahead of time to assume parallelism, but from that point on the FaaS provider automatically handles all scaling needs.***

---

State

In short you should assume that for any given invocation of a function none of the in-process or host state that you create will be available to any subsequent invocation. (FaaS functions are stateless)

--

Vendors:
- AWS Lambda
- Micorsoft Azure Functions
- Google Cloud Functions
- WebTask

Use Cases:
- Lightweight HTML apps
- API backends
- API gateways
- sandboxing untrusted code
- image/video manipulation
- data validation

Best Practices
- Functional progarmming
- Use types (typescript, Java, Go)
- Take advantage of a database, cache, or NFS for state storing across requests
